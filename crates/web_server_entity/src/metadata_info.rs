//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.11

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "metadata_info")]
pub struct Model {
  #[sea_orm(primary_key, auto_increment = false, column_type = "Text")]
  pub column_name: String,
  #[sea_orm(column_type = "Text")]
  pub column_aliases: String,
  #[sea_orm(column_type = "Text")]
  pub column_type: String,
  pub is_nullable: i32,
  #[sea_orm(column_type = "Text", nullable)]
  pub column_default: Option<String>,
  #[sea_orm(primary_key, auto_increment = false, column_type = "Text")]
  pub table_name: String,
  #[sea_orm(column_type = "Text")]
  pub table_aliases: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
  /// 将字符串从下划线命名(snake_case)转换为驼峰命名(camelCase)
  pub fn snake_to_camel_case(input: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;
    for (i, c) in input.chars().enumerate() {
      if c == '_' {
        capitalize_next = true;
      } else if capitalize_next {
        result.push(c.to_ascii_uppercase());
        capitalize_next = false;
      } else if i == 0 {
        // 第一个字符保持小写
        result.push(c.to_ascii_lowercase());
      } else {
        result.push(c);
      }
    }

    result
  }

  /// 将当前记录的所有相关字段转为驼峰命名格式并返回
  pub fn to_camel_case_map(&self) -> HashMap<String, Value> {
    let mut result = HashMap::new();
    if let Value::Object(map) = json!(self) {
      for (key, value) in map {
        result.insert(Self::snake_to_camel_case(&key), value);
      }
    }
    result
  }

  /// 将多条记录的所有字段转为驼峰格式
  pub fn batch_to_camel_case_maps(records: &[Self]) -> Vec<HashMap<String, Value>> {
    records
      .iter()
      .map(|record| record.to_camel_case_map())
      .collect()
  }

  pub async fn find_all(db: &DbConn) -> Result<Vec<Model>, DbErr> {
    Entity::find().all(db).await
  }
  pub async fn find_by_table_name(db: &DbConn, table_name: &String) -> Result<Vec<Model>, DbErr> {
    Entity::find()
      .filter(Column::TableName.eq(table_name))
      .all(db)
      .await
  }
}

//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.11

use sea_orm::{ActiveValue, entity::prelude::*};
// use serde::Deserialize;
// use validator::Validate;

use chrono::{Duration, Utc};
use common::chrono::{DATE_FORMAT, gen_now_date_time_string};
use sea_orm::prelude::Expr;
use sea_orm::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "email_code")]
pub struct Model {
  #[sea_orm(primary_key, auto_increment = false, column_type = "Text")]
  pub email: String,
  #[sea_orm(primary_key, auto_increment = false, column_type = "Text")]
  pub code: String,
  #[sea_orm(column_type = "Text", nullable)]
  pub consumed_at: Option<String>,
  #[sea_orm(column_type = "Text")]
  pub created_at: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

#[async_trait::async_trait]
impl ActiveModelBehavior for ActiveModel {
  async fn before_save<C>(self, _db: &C, insert: bool) -> Result<Self, DbErr>
  where
    C: ConnectionTrait,
  {
    if insert {
      let mut this = self;
      if this.created_at.is_not_set() {
        this.created_at = ActiveValue::Set(common::chrono::gen_now_date_time_string());
      }
      Ok(this)
    } else {
      Ok(self)
    }
  }
}

// #[derive(Debug, Validate, Deserialize)]
// pub struct Validator {
//     #[validate(required(message="邮箱不能为空"), email(message = "无效的邮箱格式"))]
//     pub email: String,
// }

// impl Validatable for ActiveModel {
//     fn validator(&self) -> Box<dyn Validate> {
//         Box::new(Validator {
//             email: self.email.as_ref().to_owned(),
//         })
//     }
// }

impl Model {
  pub async fn insert(db: &DbConn, email: String, code: String) -> Result<Model, DbErr> {
    let new_email_code = ActiveModel {
      email: Set(email),
      code: Set(code),
      ..Default::default()
    };
    new_email_code.insert(db).await
  }

  pub async fn find_by_email_and_code(
    db: &DbConn,
    email: &String,
    code: &String,
  ) -> Result<Option<Model>, DbErr> {
    Entity::find()
      .filter(Column::Email.eq(email))
      .filter(Column::Code.eq(code))
      .one(db)
      .await
  }

  pub async fn update_consumed_at_by_email_and_code(
    db: &DbConn,
    email: &String,
    code: &String,
  ) -> Result<UpdateResult, DbErr> {
    Entity::update_many()
      .filter(Column::Email.eq(email))
      .filter(Column::Code.eq(code))
      .col_expr(
        Column::ConsumedAt,
        Expr::val(gen_now_date_time_string()).into(),
      )
      .exec(db)
      .await
  }

  pub async fn find_by_email(db: &DbConn, email: &String) -> Result<Option<Model>, DbErr> {
    Entity::find()
      .filter(Column::Email.eq(email))
      .order_by_desc(Column::CreatedAt)
      .one(db)
      .await
  }

  // 删除失效的验证码 可用定时任务定期执行
  pub async fn delete_expired_codes(db: &DbConn, validity: i64) -> Result<DeleteResult, DbErr> {
    // 计算验证码的过期时间点：当前时间减去有效期
    let expiry_time = Utc::now()
      .checked_sub_signed(Duration::seconds(validity))
      .unwrap()
      .format(DATE_FORMAT)
      .to_string();

    // 删除创建时间早于过期时间点的验证码
    Entity::delete_many()
      .filter(Column::CreatedAt.lt(expiry_time))
      .exec(db)
      .await
  }
}
